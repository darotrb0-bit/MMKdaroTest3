<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Facial Recognition System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Fira Code', monospace;
            background-color: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }
        .hacker-glow {
            text-shadow: 0 0 5px rgba(52, 211, 153, 0.7), 0 0 10px rgba(52, 211, 153, 0.5);
        }
        .hacker-border {
            border: 1px solid #34d399;
            box-shadow: 0 0 10px #34d399, inset 0 0 10px #34d399;
            transition: all 0.5s ease-in-out;
        }
        input[type="file"]::file-selector-button {
            background-color: #10b981;
            color: #0d1117;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #34d399;
            box-shadow: 0 0 15px #34d399;
        }
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, #34d399, transparent);
            animation: scan 4s linear infinite;
            opacity: 0;
        }
        @keyframes scan {
            0% { top: 0; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }
        .scanning .scan-line {
            opacity: 1;
        }
        
        /* New Animations */
        .target-panel.shrunk {
            transform: scale(0.9);
            opacity: 0.7;
        }
        
        .result-card {
            opacity: 0;
            transform: scale(0.8) translateY(20px);
            animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes pop-in {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .typing-effect::after {
            content: 'â–ˆ';
            animation: blink 0.7s infinite;
            color: #34d399;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }
        
        .scan-light {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(52, 211, 153, 0.2), transparent);
            animation: scan-light-effect 1s ease-out;
        }

        @keyframes scan-light-effect {
            0% { left: -100%; }
            100% { left: 100%; }
        }

    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-2xl md:text-4xl font-bold text-emerald-400 hacker-glow">FACIAL RECOGNITION SYSTEM</h1>
            <p class="text-sm text-gray-400 mt-2">Upload an image to identify individuals from the database.</p>
        </header>

        <main id="mainGrid" class="grid grid-cols-1 md:grid-cols-2 gap-6 transition-all duration-700 ease-in-out">
            <div id="targetPanel" class="bg-gray-900/50 p-4 rounded-lg hacker-border relative overflow-hidden target-panel transition-all duration-700 ease-in-out">
                <h2 class="text-lg font-semibold text-emerald-400 mb-4 border-b border-emerald-500/30 pb-2">TARGET IMAGE</h2>
                <div id="imageContainer" class="relative min-h-[250px] flex items-center justify-center bg-black rounded-md">
                    <canvas id="canvas" class="absolute top-0 left-0"></canvas>
                    <div id="uploadPrompt" class="text-center text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                        <p class="mt-2">Waiting for image...</p>
                    </div>
                    <img id="image" class="hidden max-w-full max-h-[400px] rounded-md" />
                     <div class="scan-line"></div>
                </div>
                <div class="mt-4">
                    <input type="file" id="fileInput" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold">
                </div>
            </div>

            <div class="bg-gray-900/50 p-4 rounded-lg hacker-border flex flex-col">
                <h2 class="text-lg font-semibold text-emerald-400 mb-4 border-b border-emerald-500/30 pb-2">ANALYSIS RESULT</h2>
                <div id="results" class="flex-grow space-y-4 max-h-[450px] overflow-y-auto pr-2">
                     <p class="text-gray-500">Results will be displayed here.</p>
                </div>
                <div class="mt-4 pt-4 border-t border-emerald-500/30">
                    <button id="newScanButton" class="hidden w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2 px-4 rounded transition-all duration-300 hacker-glow">
                        START NEW SCAN
                    </button>
                </div>
            </div>
        </main>
    </div>

    <div id="loading" class="fixed inset-0 bg-black/90 flex flex-col items-center justify-center z-50 transition-opacity duration-500">
        <div class="loader animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-emerald-500"></div>
        <p id="loadingText" class="text-emerald-400 mt-4 text-lg hacker-glow">Initializing System...</p>
        <div class="w-64 mt-2 bg-gray-700 rounded-full h-2.5">
            <div id="progressBar" class="bg-emerald-500 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
        <p id="progressText" class="text-gray-400 text-sm mt-1"></p>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const imageContainer = document.getElementById('imageContainer');
        const imgElement = document.getElementById('image');
        const canvas = document.getElementById('canvas');
        const resultsDiv = document.getElementById('results');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const loadingDiv = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const targetPanel = document.getElementById('targetPanel');
        const mainGrid = document.getElementById('mainGrid');
        const newScanButton = document.getElementById('newScanButton');
        
        const GOOGLE_API_KEY = 'AIzaSyC6E9ON7DsgkMZEc6obtWehyqzGWwd_EII';
        const SHEET_ID = '1eRyPoifzyvB4oBmruNyXcoKMKPRqjk6xDD6-bPNW6pc';
        const RANGES = ['DIList!E9:E', 'DIList!L9:L', 'DIList!M9:M', 'DIList!N9:N', 'DIList!AA9:AA'];

        let labeledFaceDescriptors;
        let audioCtx;

        // --- Audio Synthesizer ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'beep') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
            } else if (type === 'scan') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        // --- Typewriter Effect ---
        function typeWriter(element, text, speed = 30) {
            let i = 0;
            element.innerHTML = '';
            element.classList.add('typing-effect');
            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    element.classList.remove('typing-effect');
                }
            }
            type();
        }

        async function loadModels() {
            loadingText.textContent = 'Loading AI Models...';
            progressBar.style.width = '10%';
            const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
            await Promise.all([
                faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL)
            ]);
        }
        
        async function fetchDataFromGoogleSheet() {
            loadingText.textContent = 'Connecting to Database...';
            progressBar.style.width = '20%';
            const rangesQuery = RANGES.map(r => `ranges=${encodeURIComponent(r)}`).join('&');
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values:batchGet?${rangesQuery}&key=${GOOGLE_API_KEY}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Google Sheets API Error: ${response.statusText}`);
                const data = await response.json();
                loadingText.textContent = 'Processing Database Records...';
                progressBar.style.width = '30%';
                const [ids, namesKm, names, genders, imageUrls] = data.valueRanges.map(range => range.values || []);
                const maxRows = Math.max(...(data.valueRanges.map(range => range.values ? range.values.length : 0)));
                const database = [];
                for (let i = 0; i < maxRows; i++) {
                    if (ids[i]?.[0] && imageUrls[i]?.[0]) {
                        database.push({
                            id: ids[i]?.[0] || '', nameKm: namesKm[i]?.[0] || '', name: names[i]?.[0] || 'N/A',
                            gender: genders[i]?.[0] || '', imageUrl: imageUrls[i]?.[0]
                        });
                    }
                }
                return database;
            } catch (error) {
                console.error("Failed to fetch data from Google Sheet:", error);
                loadingText.textContent = 'Error: Could not connect to database.';
                alert('Failed to load data from Google Sheets. Please check the Sheet ID, API Key, and ensure the sheet is public.');
                return [];
            }
        }

        async function buildFaceDatabase() {
            const database = await fetchDataFromGoogleSheet();
            if (database.length === 0) {
                if (!loadingText.textContent.startsWith('Error')) loadingText.textContent = 'Error: Database is empty or invalid.';
                return [];
            }
            loadingText.textContent = 'Building Face Index...';
            let processedCount = 0;
            const totalCount = database.length;
            const descriptors = await Promise.all(database.map(async (person) => {
                try {
                    const imageUrl = `https://corsproxy.io/?${encodeURIComponent(person.imageUrl)}`;
                    const img = await faceapi.fetchImage(imageUrl);
                    const detection = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();
                    processedCount++;
                    const progress = 30 + (processedCount / totalCount) * 60;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `(${processedCount}/${totalCount}) Analyzing ${person.name}`;
                    if (detection) return new faceapi.LabeledFaceDescriptors(JSON.stringify(person), [detection.descriptor]);
                    return null;
                } catch (error) {
                    console.error(`Could not process image for ${person.name}:`, error);
                    processedCount++;
                    const progress = 30 + (processedCount / totalCount) * 60;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `(${processedCount}/${totalCount}) ${person.name} (Image Error)`;
                    return null;
                }
            }));
            return descriptors.filter(d => d !== null);
        }

        async function initialize() {
            await loadModels();
            labeledFaceDescriptors = await buildFaceDatabase();
            if (!labeledFaceDescriptors || labeledFaceDescriptors.length === 0) {
                 if (!loadingText.textContent.startsWith('Error')) loadingText.textContent = 'Error: Could not build face database.';
                 return;
            }
            progressBar.style.width = '100%';
            loadingText.textContent = 'System Ready.';
            setTimeout(() => {
                loadingDiv.style.opacity = '0';
                loadingDiv.style.pointerEvents = 'none';
            }, 1000);
        }
        
        newScanButton.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', async () => {
            initAudio(); // Initialize audio on first user interaction
            if (fileInput.files.length === 0) return;
            if (!labeledFaceDescriptors || labeledFaceDescriptors.length === 0) {
                resultsDiv.innerHTML = '<p class="text-red-400">Database not ready or empty. Please refresh.</p>';
                return;
            }

            // Reset UI
            newScanButton.classList.add('hidden');
            targetPanel.classList.remove('shrunk');
            mainGrid.style.gridTemplateColumns = '';

            const file = fileInput.files[0];
            const imageUrl = URL.createObjectURL(file);
            resultsDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Analyzing... please wait.</p>';
            uploadPrompt.classList.add('hidden');
            imgElement.src = imageUrl;
            imgElement.classList.remove('hidden');
            imageContainer.classList.add('scanning');

            imgElement.onload = async () => {
                const displaySize = { width: imgElement.clientWidth, height: imgElement.clientHeight };
                faceapi.matchDimensions(canvas, displaySize);
                const detections = await faceapi.detectAllFaces(imgElement).withFaceLandmarks().withFaceDescriptors();
                faceapi.resizeResults(detections, displaySize);
                resultsDiv.innerHTML = '';
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);

                if (detections.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-red-400">No faces detected.</p>';
                } else {
                    targetPanel.classList.add('shrunk');
                    if(window.innerWidth > 768) mainGrid.style.gridTemplateColumns = '0.5fr 1.5fr';

                    for (const [index, detection] of detections.entries()) {
                        const allMatches = labeledFaceDescriptors.map(ld => {
                            const distance = faceapi.euclideanDistance(detection.descriptor, ld.descriptors[0]);
                            return { distance, labelData: JSON.parse(ld.label) };
                        }).sort((a, b) => a.distance - b.distance);
                        const topMatches = allMatches.slice(0, 4);
                        const bestMatchData = topMatches[0]?.labelData?.name || 'Unknown';
                        const bestMatchIsKnown = (topMatches[0]?.distance || 1) < 0.6;

                        const drawBox = new faceapi.draw.DrawBox(detection.detection.box, {
                            label: `${bestMatchData} (Face ${index + 1})`,
                            boxColor: bestMatchIsKnown ? '#34d399' : '#f87171'
                        });
                        drawBox.draw(canvas);

                        await displayFaceResults(topMatches, index + 1);
                    }
                }
                if (resultsDiv.innerHTML === '') resultsDiv.innerHTML = '<p class="text-yellow-400">No close matches found.</p>';
                imageContainer.classList.remove('scanning');
                URL.revokeObjectURL(imageUrl);
                newScanButton.classList.remove('hidden'); // Show button after analysis
            };
        });
        
        async function displayFaceResults(matches, faceIndex) {
            const faceResultContainer = document.createElement('div');
            faceResultContainer.className = 'mb-6 p-3 border border-gray-700 rounded-lg';
            const title = document.createElement('h3');
            title.className = 'text-md font-bold text-emerald-400 mb-3';
            faceResultContainer.appendChild(title);
            resultsDiv.appendChild(faceResultContainer);
            typeWriter(title, `Potential Matches for Face #${faceIndex}`);
            
            await new Promise(res => setTimeout(res, 500));

            for (const [index, match] of matches.entries()) {
                const { distance, labelData } = match;
                const confidence = ((1 - distance) * 100).toFixed(2);
                
                let cardClasses = 'bg-black/50 p-3 rounded-lg border border-emerald-500/30 flex items-start space-x-4 mb-2 relative overflow-hidden result-card';
                let nameBlock = '<p class="data-name text-lg font-bold text-white"></p>';
                
                if (index === 0) {
                    cardClasses = 'bg-black/50 p-3 rounded-lg border-2 border-emerald-400 flex items-start space-x-4 mb-2 relative overflow-hidden result-card';
                    // **FIX:** Moved BEST MATCH indicator next to the name, off the image
                    nameBlock = `
                        <div class="flex items-center gap-2">
                            <p class="data-name text-lg font-bold text-white"></p>
                            <span class="text-xs bg-emerald-500 text-black font-bold py-0.5 px-1.5 rounded">BEST MATCH</span>
                        </div>
                    `;
                }
                
                const resultCard = document.createElement('div');
                resultCard.className = cardClasses;
                
                const cardContent = `
                    <div class="scan-light"></div>
                    <div class="relative w-20 h-24 flex-shrink-0">
                        <img src="${labelData.imageUrl}" class="w-full h-full object-cover rounded-md border-2 border-emerald-600" alt="Matched Photo" onerror="this.src='https://placehold.co/80x96/000000/34d399?text=Error'">
                    </div>
                    <div class="flex-grow">
                        ${nameBlock}
                        <p class="data-name-km text-md text-gray-300"></p>
                        <p class="data-id text-sm text-gray-400"></p>
                        <p class="data-gender text-sm text-gray-400"></p>
                        <div class="mt-2">
                            <span class="data-confidence font-semibold ${confidence > 50 ? 'text-emerald-400' : 'text-yellow-400'}"></span>
                        </div>
                    </div>
                `;
                resultCard.innerHTML = cardContent;
                faceResultContainer.appendChild(resultCard);
                playSound(index === 0 ? 'beep' : 'scan');

                // Animate text content
                typeWriter(resultCard.querySelector('.data-name'), labelData.name);
                await new Promise(res => setTimeout(res, 200));
                typeWriter(resultCard.querySelector('.data-name-km'), labelData.nameKm);
                await new Promise(res => setTimeout(res, 200));
                typeWriter(resultCard.querySelector('.data-id'), `ID: ${labelData.id}`);
                 await new Promise(res => setTimeout(res, 200));
                typeWriter(resultCard.querySelector('.data-gender'), `Gender: ${labelData.gender}`);
                await new Promise(res => setTimeout(res, 200));
                typeWriter(resultCard.querySelector('.data-confidence'), `Confidence: ${confidence}%`);

                await new Promise(res => setTimeout(res, 800)); // Wait before showing next card
            }
        }
        initialize();
    </script>
</body>
</html>

